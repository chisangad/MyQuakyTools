#' Plot venn diagram of DE genes
#' @description
#' Wrapper function to plot the Venn diagram generated by the \code{\link[limma:vennDiagram]{vennDiagram}}
#'
#' @param status DE status output from \code{\link[limma:decideTests]{decideTests}}
#' @param inset numeric vector of values used to place the legend on the venn diagram
#' @param de.cols vector of colors used to represent the DE status
#' @param include vector used to represent the DE status
#' @param leg.bg background color of the legend
#' @param leg.box_col box color for the legend
#' @param leg.cex size for legend text
#' @param ... all other parameters are passed to \code{\link[limma:vennDiagram]{vennDiagram}}
#' @return
#' A Venn diagram is plotted to the graphics object
#' @export
plot_DEVenn=function(status,inset=c(0.19,0.10),de.cols,include = c("up","down"),leg.bg="white",
                     leg.box_col="white",leg.cex=0.6,...)
{
  limma::vennDiagram(status,cex.main=0.8,include = include,
                     show.include = T,counts.col = de.cols,...)
  par(xpd = TRUE)
  legend("bottomright",legend=c(sum(rowSums(status==1)>0),sum(rowSums(status==-1)>0)),
         inset = inset,bg=leg.bg,col = de.cols,text.col = de.cols,
         box.col = leg.box_col,cex = leg.cex)
}


#'Modified barcodeplot function
#'
#'
#'@export


plotbarcode<-function (statistics, index = NULL, index2 = NULL, gene.weights = NULL,
                       weights.label = "Weight", labels = c("Down", "Up"),
                       quantiles = c(-1, 1) * sqrt(2), col.bars = NULL, alpha = 0.4, worm = TRUE,
                       span.worm = 0.45, xlab = "Statistic",split.worm=T,col.uenrich="pink",
                       col.denrich="lightblue",enrichment.height=NULL,...)
{
  if (!is.vector(statistics, mode = "numeric"))
    stop("statistics should be a numeric vector")
  nstat <- length(statistics)
  if (is.null(index)) {
    if (is.null(gene.weights)) {
      stop("Must specify at least one of index or gene.weights")
    }
    else {
      if (length(gene.weights) == nstat) {
        index <- rep_len(TRUE, nstat)
        index2 <- NULL
      }
      else {
        stop("No index and length(gene.weights) doesn't equal length(statistics)")
      }
    }
  }
  else {
    if (any(is.na(index)))
      stop("Need to provide index without NAs")
    if (is.logical(index))
      if (length(index) != nstat)
        stop("Length of index disagrees with statistics")
    if (length(index) > nstat)
      stop("Length of index disagrees with statistics")
  }
  if (!is.null(index2)) {
    if (!is.null(gene.weights))
      warning("gene.weights ignored")
    gene.weights <- statistics
    gene.weights[] <- 0
    gene.weights[index] <- 1
    gene.weights[index2] <- -1
    index <- rep_len(TRUE, nstat)
    index2 <- NULL
  }
  if (!is.null(gene.weights)) {
    if (!is.vector(gene.weights, mode = "numeric"))
      stop("gene.weights should be a numeric vector")
    if (any(is.na(gene.weights)))
      stop("Need to provide gene.weights without NAs")
    if (all(gene.weights == 0))
      stop("gene.weights equal to zero: no selected genes to plot")
    if (length(gene.weights) != length(statistics[index]))
      stop("Length of gene.weights disagrees with size of set")
    one <- all(gene.weights >= 0) | all(gene.weights <= 0)
    if (one) {
      index2 <- NULL
      gene.weights1 <- rep_len(0, nstat)
      names(gene.weights1) <- names(statistics)
      gene.weights1[index] <- gene.weights
      index <- rep_len(FALSE, nstat)
      names(index) <- names(statistics)
      index[gene.weights1 != 0] <- TRUE
      gene.weights1 <- gene.weights1[gene.weights1 != 0]
      gene.weights <- gene.weights1
    }
    else {
      gene.weights12 <- rep_len(0, nstat)
      names(gene.weights12) <- names(statistics)
      gene.weights12[index] <- gene.weights
      index <- index2 <- rep_len(FALSE, nstat)
      names(index) <- names(index2) <- names(statistics)
      index[gene.weights12 > 0] <- TRUE
      index2[gene.weights12 < 0] <- TRUE
      gene.weights1 <- gene.weights12[gene.weights12 >
                                        0]
      gene.weights2 <- gene.weights12[gene.weights12 <
                                        0]
      gene.weights <- gene.weights1
    }
  }
  TWO <- !is.null(index2)
  set1 <- set2 <- data.frame(idx = rep.int(FALSE, nstat), weight = NA,
                             wt = NA)
  set1$idx[index] <- TRUE
  if (TWO)
    set2$idx[index2] <- TRUE
  if (length(gene.weights)) {
    set1$weight <- 0
    set1$weight[index] <- gene.weights
    set1$wt <- abs(set1$weight)/sum(abs(set1$weight))
    if (TWO) {
      set2$weight <- 0
      set2$weight[index2] <- gene.weights2
      SUM <- sum(abs(set1$weight), abs(set2$weight))
      set1$wt <- abs(set1$weight)/SUM
      set2$wt <- abs(set2$weight)/SUM
    }
  }
  ostat <- order(statistics, na.last = TRUE, decreasing = FALSE)
  statistics <- statistics[ostat]
  set1 <- set1[ostat, ]
  if (TWO)
    set2 <- set2[ostat, ]
  n <- sum(!is.na(statistics))
  if (n == 0L) {
    message("No valid statistics")
    return(invisible())
  }
  if (n < nstat) {
    statistics <- statistics[1:n]
    set1 <- set1[1:n, ]
    if (TWO)
      set2 <- set2[1:n, ]
  }
  r <- which(set1$idx)
  if (TWO) {
    r2 <- which(set2$idx)
    if (!length(r2))
      TWO <- FALSE
  }
  if (!length(r))
    if (TWO) {
      r <- r2
      set1 <- set2
      TWO <- FALSE
    }
  else {
    message("No selected genes to plot")
    return(invisible())
  }
  WTS <- FALSE
  wt1 <- set1$wt[r]
  len.up <- 1
  if (all(!is.na(wt1))) {
    len.up <- set1$weight[r]/max(abs(set1$weight[r]))
    anydifferent <- function(x) {
      if (length(x) < 2)
        return(FALSE)
      r <- range(x)
      (r[2] > r[1])
    }
    if (!TWO)
      if (anydifferent(wt1))
        WTS <- TRUE
    if (TWO) {
      wt12 <- c(set1$wt[r], abs(set2$wt[r2]))
      if (anydifferent(wt12))
        WTS <- TRUE
      max.wt <- max(set1$wt[r], set2$wt[r2])
      len.up <- set1$wt[r]/max.wt
      len.down <- set2$wt[r2]/max.wt
    }
  }
  pos.dir <- all(len.up > 0)
  if (WTS)
    shift <- 0.1
  else shift <- 0
  quantiles <- sort(quantiles)
  ALP <- alpha
  ALP <- min(ALP, 1)
  ALP <- max(ALP, 0.1)
  if (is.null(col.bars)) {
    if (TWO) {
      col.bars <- c("red", "blue")
      if (WTS)
        col.bars.alpha <- c(rgb(1, 0, 0, alpha = ALP),
                            rgb(0, 0, 1, alpha = ALP))
      else col.bars.alpha <- col.bars
    }
    else {
      col.bars <- "black"
      if (WTS)
        col.bars.alpha <- rgb(0, 0, 0, alpha = ALP)
      else col.bars.alpha <- col.bars
    }
  }
  else {
    if (TWO) {
      if (length(col.bars) == 1)
        col.bars <- rep(col.bars, 2)
      RGB <- col2rgb(col.bars)/255
      red <- RGB[1, 1]
      green <- RGB[2, 1]
      blue <- RGB[3, 1]
      red2 <- RGB[1, 2]
      green2 <- RGB[2, 2]
      blue2 <- RGB[3, 2]
      if (WTS)
        col.bars.alpha <- c(rgb(red, green, blue, alpha = ALP),
                            rgb(red2, green2, blue2, alpha = ALP))
      else col.bars.alpha <- col.bars
    }
    else {
      RGB <- col2rgb(col.bars)/255
      red <- RGB[1, 1]
      green <- RGB[2, 1]
      blue <- RGB[3, 1]
      if (WTS)
        col.bars.alpha <- rgb(red, green, blue, alpha = ALP)
      else col.bars.alpha <- col.bars
    }
  }
  ylim.worm <- ylim <- c(-1, 1)
  ylab.worm <- ""
  xlab.worm <- xlab
  if (!TWO&!split.worm)
    ylim.worm <- c(0, 1)
  if (worm) {
    ylim.worm <- c(-2.1, 2.1)
    if (!TWO&split.worm)
      ylim.worm <- c(0, 2.1)
    if(!split.worm)
      ylim.worm <- c(-1, 2.1)
  }
  ylim[2] <- ylim[2] + 0.5
  if (TWO)
    ylim[1] <- ylim[1] - 0.5
  if (TWO)
    plot(1:n, xlim = c(0, n), ylim = c(ylim.worm[1] - shift,
                                       ylim.worm[2] + shift),
         type = "n", axes = FALSE,
         xlab = xlab.worm, ylab = ylab.worm, ...)
  if (!TWO)
    plot(1:n, xlim = c(0, n), ylim = c(ylim.worm[1] - shift *(!pos.dir),
                                       ylim.worm[2] + shift * pos.dir),
         type = "n",axes = FALSE, xlab = xlab.worm, ylab = ylab.worm,...)
  npos <- sum(statistics > quantiles[2])
  nneg <- sum(statistics < quantiles[1])
  lwd <- 50/length(r)
  lwd <- min(1.9, lwd)
  lwd <- max(0.2, lwd)
  if (TWO) {
    lwd2 <- 50/length(r2)
    lwd2 <- min(1.9, lwd2)
    lwd2 <- max(0.2, lwd2)
    lwd <- lwd2 <- min(lwd, lwd2)
  }
  barlim <- ylim[2] - c(1.5, 0.5)
  if (!pos.dir) {
    rect.yb <- 0.5
    rect.yt <- 1
    rect(nneg + 0.5, rect.yb, n - npos + 0.5, rect.yt, col = "lightgray",
         border = NA)
    if (nneg)
      rect(0.5, rect.yb, nneg + 0.5, rect.yt, col = col.denrich,
           border = NA)
    if (npos)
      rect(n - npos + 0.5, rect.yb, n + 0.5, rect.yt, col = col.uenrich,
           border = NA)
    segments(r, barlim[2]/2, r, barlim[2], lwd = lwd, col = col.bars.alpha[1])
    segments(r, barlim[2]/2 - shift, r, barlim[2]/2 * (1 + len.up) - shift,
             lwd = lwd, col = col.bars[1])
  }
  if (pos.dir) {
    rect.yb <- -0.5
    if (!TWO)
      rect.yb <- 0
    rect.yt <- 0.5
    rect(nneg + 0.5, rect.yb, n - npos + 0.5, rect.yt, col = "lightgray",
         border = NA)
    if (nneg)
      rect(0.5, rect.yb, nneg + 0.5, rect.yt, col = col.denrich,
           border = NA)
    if (npos)
      rect(n - npos + 0.5, rect.yb, n + 0.5, rect.yt, col = col.uenrich,
           border = NA)
    segments(r, barlim[1], r, barlim[2]/2, lwd = lwd, col = col.bars.alpha[1])
    segments(r, barlim[2]/2 + shift, r, barlim[2]/2 * (1 +len.up) + shift,
             lwd = lwd, col = col.bars[1])
  }
  if (TWO) {
    barlim2 <- ylim[1] + c(0.5, 1.5)
    segments(r2, barlim2[1]/2, r2, barlim2[2], lwd = lwd2,
             col = col.bars.alpha[2])
    segments(r2, barlim2[1]/2 * (1 + len.down) - shift, r2,
             barlim2[1]/2 - shift, lwd = lwd2, col = col.bars[2])
  }
  lab.at <- 0
  if (!TWO)
    lab.at <- 0.5
  axis(side = 2, at = lab.at, padj = 3.8, cex.axis = 0.85,
       labels = labels[1], tick = FALSE)
  axis(side = 4, at = lab.at, padj = -3.8, cex.axis = 0.85,
       labels = labels[2], tick = FALSE)
  prob <- (0:10)/10
  axis(at = seq(1, n, len = 11), side = 1, cex.axis = 0.7,
       las = 2, labels = format(quantile(statistics, p = prob),
                                digits = 1))
  if (worm) {
    rescale <- function(x, newrange, oldrange = range(x)) {
      newrange[1] + (x - oldrange[1])/(oldrange[2] - oldrange[1]) *
        (newrange[2] - newrange[1])
    }
    if (!WTS) {
      ave.enrich1 <- length(r)/n
      worm1 <- tricubeMovingAverage(set1$idx, span = span.worm)/ave.enrich1
      if (TWO){
        if(split.worm)
        {
          ave.enrich2 <- length(r2)/n
          worm2 <- tricubeMovingAverage(-set2$idx, span = span.worm)/ave.enrich2
        }
        else{
          ave.enrich2 <- length(r2)/n
          worm2 <- tricubeMovingAverage(set2$idx, span = span.worm)/ave.enrich2
        }
      }
    }
    if (WTS) {
      ave.enrich1 <- mean(set1$wt)
      worm1 <- tricubeMovingAverage(set1$wt, span = span.worm)/ave.enrich1
      if (TWO&split.worm) {
        ave.enrich2 <- mean(set2$wt)
        worm2 <- tricubeMovingAverage(-set2$wt, span = span.worm)/ave.enrich2
      }
      else
      {
        ave.enrich2 <- mean(set2$wt)
        worm2 <- tricubeMovingAverage(set2$wt, span = span.worm)/ave.enrich2
      }
    }
    max.worm1 <- max(c(worm1,abs(worm2)))
    if(!is.null(enrichment.height))
      max.worm1<-1*enrichment.height
    r.worm1 <- c(0, max.worm1)
    worm1.scale <- rescale(worm1, newrange = c(1.1 + shift *pos.dir, 2.1 + shift * pos.dir),
                           oldrange = r.worm1)
    if (TWO) {
      if(split.worm)
      {
        min.worm2 <- -max(c(worm1,abs(worm2)))
        if(!is.null(enrichment.height))
          min.worm2<--enrichment.height
        r.worm2 <- c(min.worm2, 0)
        #worm2.pos<-
        worm2.scale <- rescale(worm2, newrange = c(-2.1-shift,-1.1-shift),
                               oldrange = r.worm2)
      }
      else{
        max.worm2 <- max(worm2)
        if(!is.null(enrichment.height)) max.worm2<-enrichment.height
        r.worm2 <- c(0, max.worm2)
        worm2.scale <- rescale(worm2, newrange = c(1.1 + shift *pos.dir, 2.1 + shift * pos.dir),
                               oldrange = r.worm2)
      }
    }

    if (!TWO) {
      lines(x = 1:n, y = worm1.scale, col = col.bars[1],lwd = 2)
      abline(h = rescale(1, newrange = c(1.1 + shift *pos.dir, 2.1 + shift * pos.dir),
                         oldrange = r.worm1),lty = 2)
      axis(side = 2, at = c(1.1 + shift * pos.dir, 2.1 +shift * pos.dir),
           cex.axis = 0.8, labels = c(0,format(max.worm1, digits = 2)))
      axis(side = 2, labels = "Enrichment", at = 1.6 +shift * pos.dir,
           padj = -0.6, tick = FALSE, cex.axis = 0.8)
    }
    if (TWO) {
      lines(x = 1:n, y = worm1.scale, col = col.bars[1],
            lwd = 2)
      abline(h = rescale(1, newrange = c(1.1 + shift, 2.1 +shift),
                         oldrange = r.worm1), lty = 2)
      lines(x = 1:n, y = worm2.scale, col = col.bars[2],
            lwd = 2)
      if(split.worm)
        abline(h = rescale(-1, newrange = c(-2.1 - shift,-1.1 - shift),
                           oldrange = r.worm2), lty = 2)
      axis(side = 2, at = c(1.1 + shift, 2.1 + shift),
           cex.axis = 0.7, labels = c(0, format(max.worm1,
                                                digits = 2)))
      if(split.worm)
        axis(side = 2, at = c(-1.1 - shift, -2.1 - shift),
             cex.axis = 0.7, labels = c(0, format(-min.worm2,
                                                  digits = 2)))
      axis(side = 2, labels = "Enrichment", at = 1.6 +
             shift, tick = FALSE, padj = -0.6, cex.axis = 0.7)
      if(split.worm)
        axis(side = 2, labels = "Enrichment", at = -1.6 -
               shift, tick = FALSE, padj = -0.6, cex.axis = 0.7)
    }
  }
  if (WTS) {
    if (!TWO) {
      if (pos.dir) {
        axis(side = 2, at = c(0.5 + shift, 1 + shift),
             cex.axis = 0.48, padj = 1.6, labels = c(
               0,format(max(set1$weight[r]), digits = 2)))
        axis(side = 2, labels = weights.label[1], at = 0.75 +
               shift, padj = 1, tick = FALSE, cex.axis = 0.5)
      }
      if (!pos.dir) {
        axis(side = 2, at = c(0 - shift, 0.5 - shift),
             cex.axis = 0.48, padj = 1.6, labels = c(format(min(set1$weight[r]),
                                                            digits = 2), 0))
        axis(side = 2, labels = weights.label[1], at = 0.25 -
               shift, padj = 1, tick = FALSE, cex.axis = 0.5)
      }
    }
    if (TWO) {
      max.weight <- max(set1$weight[r], abs(set2$weight[r2]))
      axis(side = 2, at = c(0.5 + shift, 1 + shift), cex.axis = 0.43,
           labels = c(0, format(max.weight, digits = 2,
                                scientific = FALSE)), padj = 1.6)
      axis(side = 2, labels = weights.label[1], at = 0.75 +
             shift, padj = 1, tick = FALSE, cex.axis = 0.46)

      axis(side = 2, at = c(-0.5 - shift, -1 - shift),
           cex.axis = 0.43, labels = c(0, format(
             -max.weight,digits = 2, scientific = FALSE)), padj = 1.6)
      axis(side = 2, labels = weights.label[1], at = -0.75 -
             shift, padj = 1, tick = FALSE, cex.axis = 0.46)

    }
  }
  invisible()
}



#' @title Include space between labels
#' @description
#' A function to space labels on a plot with Arrows, usually MDS plots and Volcano plot
#' @author David Chisanga
#' @param labelCoords a numeric vector list of coordinates
#' @param minDist The minimum expected distance between near labels
#' @examples
#' labels=list(seq(1,3,0.3))
#' names(labels)=paste0("Label0000",1:length(labels))
#' spaceLabels(labels,0.5)
#' @return Returns a vector of spaced coordinates for labels
spaceLabels_newww <- function(labelCoords, minDist = 0.4)
{
  named = T
  if (length(labelCoords) > 1)
  {
    if (is.null(names(labelCoords)))
    {
      names(labelCoords) = paste0("l", 1:length(labelCoords))
      named = F
    }
    #Reorder the coordinates by ascending order
    labelCoords.sorted = labelCoords[names(labelCoords)[order(unlist(labelCoords), decreasing = F)]]
    for (idx in 1:length(labelCoords.sorted))
    {
      g1 = names(labelCoords.sorted)[idx]
      g2 = ifelse(idx != length(labelCoords.sorted),
                  names(labelCoords.sorted)[idx + 1],
                  g1)
      diff = labelCoords.sorted[g2] - labelCoords.sorted[g1]
      if (g1 != g2 & diff < minDist)
        labelCoords.sorted[g2] = labelCoords.sorted[g2] + minDist - diff
    }
    labelCoords[names(labelCoords.sorted)] = labelCoords.sorted
    if (!named)
      unlist(labelCoords, use.names = F)
  }
  return(labelCoords)
}


#' @title Space text labels
#' @description This function is used to space multiple text labels
#' @author David Chisanga
#' @param labelCoords a numeric vector list of coordinates
#' @param minDist The minimum expected distance between near labels
#' @examples
#' labels=list(seq(1,3,0.3))
#' names(labels)=paste0("Label0000",1:length(labels))
#' spaceLabels(labels,0.5)
#'
#' @export
#' @return Returns a vector of spaced coordinates for labels
spaceLabels_new <- function(labelCoords, minDist = 0.4,boundaries=c(0,max(labelCoords)+2))
{
  named=T
  if(is.null(names(labelCoords)))
  {
    names(labelCoords)=paste0("p",c(1:length(labelCoords)))
    named=F
  }
  coords.count=length(labelCoords)
  if(coords.count>100)
    cat(coords.count," is a lot of points to label! ",
                "Consider reducing the number of points and try again")
  coord.names=names(labelCoords)
  labelCoords=sort(labelCoords)
  diffs=unlist(labelCoords[2:coords.count]-labelCoords[1:(coords.count-1)],
               use.names = F)
  print(min(diffs)>minDist)
  #Check minimum spacing between labels and space them equally
  if(min(diffs)>minDist)
  {
    y=seq(from=boundaries[1],to=boundaries[2],length.out = coords.count)
  }
  else
  {
    cat("Spacing small")
    y=(0:(coords.count-1))*minDist+boundaries[1]
    if(max(y)>boundaries[2])
      y=y*boundaries[2]/max(y)
  }
  names(y)=names(labelCoords)
  labelCoords=y
  labelCoords=labelCoords[coord.names]
  if(!named)
    names(labelCoords)=NULL
  return(labelCoords)
}


#' Generate label coordinates
#' @description
#' A function to space labels on a plot with Arrows, usually MDS plots and Volcano plot
#' @author David Chisanga
#' @param axis String of axis on which labels/arrows are shown, values include x-axis or y-axis. y-axis by default
#' @param minDist The minimum expected distance between near labels
#' @param max.distance numeric, the maximum distance from the 0 coordinate to place labels, 11 by default
#' @param arrow.coordinates list of numeric coordinates on the axis on which labels will be placed
#' @param label.coordinates list of numeric coordinates on the other axis for labels
#' @export
#' @return Returns a list of spaced coordinates

spaceLabels <- function(labelCoords, minDist = 0.4)
{
  named = T
  if (length(labelCoords) > 1)
  {
    if (is.null(names(labelCoords)))
    {
      names(labelCoords) = paste0("l", 1:length(labelCoords))
      named = F
    }
    #Reorder the coordinates by ascending order
    labelCoords.sorted = labelCoords[names(labelCoords)[order(unlist(labelCoords), decreasing = F)]]
    for (idx in 1:length(labelCoords.sorted))
    {
      g1 = names(labelCoords.sorted)[idx]
      g2 = ifelse(idx != length(labelCoords.sorted),
                  names(labelCoords.sorted)[idx + 1],
                  g1)
      diff = labelCoords.sorted[g2] - labelCoords.sorted[g1]
      if (g1 != g2 & diff < minDist)
        labelCoords.sorted[g2] = labelCoords.sorted[g2] + minDist - diff
    }
    labelCoords[names(labelCoords.sorted)] = labelCoords.sorted
    if (!named)
      unlist(labelCoords, use.names = F)
  }
  return(labelCoords)
}

#' Generate label coordinates
#' @description
#' A function to space labels on a plot with Arrows, usually MDS plots and Volcano plot
#' @author David Chisanga
#' @param axis String of axis on which labels/arrows are shown, values include x-axis or y-axis. y-axis by default
#' @param minDist The minimum expected distance between near labels
#' @param max.distance numeric, the maximum distance from the 0 coordinate to place labels, 11 by default
#' @param arrow.coordinates list of numeric coordinates on the axis on which labels will be placed
#' @param label.coordinates list of numeric coordinates on the other axis for labels
#' @export
#' @return Returns a list of spaced coordinates
getLabelCoordinates <-
  function(axis = "y-axis",
           max.distance = 6,
           arrow.coordinates,
           label.coordinates,
           minDist)
  {
    if (axis == "y-axis")
    {
      g.y = ar.y = arrow.coordinates
      g.x1 = label.coordinates
      ar.y = rep(max.distance, length(g.y))
      ar.y[g.y < 0] = -(max.distance - 0.5)
      ar.y[g.y >= ar.y & ar.y > 0] = g.y[g.y >= ar.y & ar.y > 0]
      ar.y[g.y <= ar.y & ar.y < 0] = g.y[g.y <= ar.y & ar.y < 0]
      g.x1[g.y < 0] = spaceLabels(g.x1[g.y < 0], minDist = minDist)
      g.x1[g.y > 0] = spaceLabels(g.x1[g.y > 0], minDist = minDist)
      g.x1[g.y >= ar.y & ar.y > 0] = g.x1[g.y >= ar.y & ar.y > 0] - 1
      g.x1[g.y <= ar.y & ar.y < 0] = g.x1[g.y <= ar.y & ar.y < 0] - 1
      return(list(arrow.y = ar.y, label.x = g.x1))
    }
    else{
      ar.y = arrow.coordinates
      ar.x = label.coordinates
      ar.y[ar.x > 0] = spaceLabels(ar.y[ar.x >= 0], minDist = 0.25)
      ar.y[ar.x < 0] = spaceLabels(ar.y[ar.x <= 0], minDist = 0.25)
      ar.x[ar.x < 0] = ar.x[ar.x < 0] - 0.7
      ar.x[ar.x > 0] = ar.x[ar.x > 0] + 0.7
      return(list(arrow.y = ar.y, label.x = ar.x))
    }
  }



getLabelCoordinates_new_new <-
  function(axis = "y-axis",
           max.distance = 6,
           arrow.coordinates,
           label.coordinates,
           minDist)
  {
    if (axis == "y-axis")
    {
      g.y = ar.y = arrow.coordinates
      g.x1 = label.coordinates
      ar.y = rep(max.distance, length(g.y))
      ar.y[g.y < 0] = -(max.distance - 0.5)
      ar.y[g.y >= ar.y & ar.y > 0] = g.y[g.y >= ar.y & ar.y > 0]
      ar.y[g.y <= ar.y & ar.y < 0] = g.y[g.y <= ar.y & ar.y < 0]
      g.x1[g.y < 0] = spaceLabels(g.x1[g.y < 0], minDist = minDist)
      g.x1[g.y > 0] = spaceLabels(g.x1[g.y > 0], minDist = minDist)
      g.x1[g.y >= ar.y & ar.y > 0] = g.x1[g.y >= ar.y & ar.y > 0] - 1
      g.x1[g.y <= ar.y & ar.y < 0] = g.x1[g.y <= ar.y & ar.y < 0] - 1
      return(list(arrow.y = ar.y, label.x = g.x1))
    }
    else{
      ar.y = arrow.coordinates
      ar.x = label.coordinates
      ar.y[ar.x > 0] = spaceLabels(ar.y[ar.x >= 0], minDist = 0.25)
      ar.y[ar.x < 0] = spaceLabels(ar.y[ar.x <= 0], minDist = 0.25)
      ar.x[ar.x < 0] = ar.x[ar.x < 0] - 0.7
      ar.x[ar.x > 0] = ar.x[ar.x > 0] + 0.7
      return(list(arrow.y = ar.y, label.x = ar.x))
    }
}


#'Wrapper function to include arrows to a MD plot in limma
#'
#'@author David Chisanga
#'@param x numeric coordinate of arrow on the x-axis
#'@param y numeric coordiate of arrow on the y-axis
#'@param x.inset value to extend the start of the x-coordinate of label
#'@param y.inset value to extend the start of the y-coordinate of label
#'@param min.dist The minimum expected distance between near labels
#'@param symbols character of gene symbols to be used in labelling
#'@param cex size of labels
#'@param text.srt angle rotation for labels
#'@param arrow.angle angle of arrows
#'@param col.lbl character vector of colors for labels
#'@export

labelMDplot<-function(x,y,min.dist=0.4,y.inset=0.8,x.inset=0.8,symbols,cex.lbl=0.7,
                      arrow.angle=30,text.srt=90,col.lbl="black",axis="y-axis",
                      col.arrow = "black",max.distance=7)
{
  coords=getLabelCoordinates(arrow.coordinates = y,minDist = min.dist,
                             label.coordinates = x,axis = axis,
                             max.distance = max.distance)
  ar.y=coords$arrow.y
  g.x1=coords$label.x
  if(axis=="y-axis")
  {
    arrows(x0 = x,y0 = y,length = 0,col = col.arrow,
           x1=g.x1,y=ar.y,angle = arrow.angle);
  }
  else{
    arrows(x0 = y,y0 = x,length = 0,col = col.arrow,
           x1=g.x1,y=ar.y,angle = arrow.angle)
  }
  ar.y[ar.y>=0&ar.y>y]=ar.y[ar.y>=0&ar.y>y]+y.inset
  ar.y[ar.y<0&ar.y<y]=ar.y[ar.y<0&ar.y<y]-x.inset
  text(x =g.x1,y=ar.y,symbols,srt=text.srt,cex=cex.lbl,
       col = col.lbl)
}


#' plot volcano
#' @description
#' Function to generate volcano plot
#'
#' @author David Chisanga
#'
#' @param top.matrix A matrix retained by either \code{\link[limma:topTable]{topTable}} or \code{\link[limma:topTreat]{topTreat}}
#' @param status results from decideTest with the DE status
#' @param title Text to be used for the title of the plot
#' @param xlim limits on the x-axis
#' @param ylim limits on the y-axis
#' @param label.Ids gene IDs for the genes to be used for highlighting genes on the plot
#' @param cex.lbl plot size for the highlighted text
#' @param minDist minimum distance between text used to determine the proximity of highlighted text
#' @param angle angle used to rotate the arrows
#' @param arrow.col colour used for the arrows.
#' @param de.cols vector list of colours used for highlght up-regulated and down-regulated genes
#' @param cex.points minimum plot size for the points
#' @param key.size factor to multiply the minimum plot size for DE points
#' @export

plotVolcalno<-function(top.matrix,status,title="",ylim=c(0,11),xlim=c(-10,10),
                       label.Ids=NA,cex.lbl=0.6,minDist = 0.25,use.raw=F,
                       angle=30,arrow.col="black",de.cols=c("red","blue"))
{

  top.matrix<-top.matrix[rownames(status),]
  de.genes<-status
  dot.cols<-de.genes
  x<-top.matrix$logFC
  y<-(-log10(top.matrix$adj.P.Val))
  if(use.raw)
    y<-(-log10(top.matrix$P.Value))
  dot.cols[de.genes==1]=de.cols[1]
  dot.cols[de.genes==-1]=de.cols[2]
  dot.cols[de.genes==0]<-"black"
  de.genes<-unlist(de.genes,use.names = F)!=0
  pch=rep(16,nrow(top.matrix))
  bg=dot.cols
  not.de<-!de.genes
  if(!is.null(label.Ids))
  {
    idx=match(label.Ids,top.matrix$GeneID)
    pch[idx]=21
    dot.cols[idx]="yellow"
    not.de[idx]<-F
    de.genes[idx]<-T
  }
  plot(x[not.de],y[not.de],ylab = "-log10(p.value)",
       xlab = "log2 fold-change",cex=0.6,
       cex.main=1,main = title,ylim=ylim,col=dot.cols[not.de],
       pch=pch[not.de],xlim=xlim,bg=bg[not.de])
  if(!is.null(label.Ids))
    de.genes[idx]=F
  lines(x[de.genes],y[de.genes],col=dot.cols[de.genes],
        type = "p",pch=pch[de.genes],cex=1.2,bg=bg[de.genes])
  if(!is.null(label.Ids))
  {
    lines(x[idx],y[idx],col=dot.cols[idx],
          type = "p",pch=pch[idx],cex=1.2,bg=bg[idx])
    fc2=x[idx]
    pval=y[idx]
    ar.x=rep((xlim[2]-2),length(label.Ids))
    ar.x[fc2<0]=xlim[1]+2
    ar.y=getLabelCoordinates(axis = "x-axis",max.distance = 10,
                             label.coordinates = ar.x,
                             arrow.coordinates = pval,
                             minDist = minDist)$arrow.y
    arrows(fc2,pval, x1 = ar.x, y1 =ar.y,
           length = 0, angle = angle,col = arrow.col)
    ar.x[ar.x<0]=ar.x[ar.x<0]-0.7
    ar.x[ar.x>0]=ar.x[ar.x>0]+0.7
    genes.2H=top.matrix$Symbol[idx]
    text(x =ar.x,y = ar.y,labels = genes.2H,cex=cex.lbl)
  }
}

plotVolcalno_new<-function(top.matrix,status,title="Volcano plot",ylim=c(0,11),xlim=c(-10,10),
                       label.Ids=NA,cex.lbl=0.6,minDist = 0.25,use.raw=F,
                       cex.points=0.6,angle=30,arrow.col="black",key.size=1.5,
                       de.cols=c("red","blue"))
{
  top.matrix<-top.matrix[names(status),]
  de.genes<-status
  dot.cols<-de.genes
  x<-top.matrix$logFC
  y<-(-log10(top.matrix$adj.P.Val))
  if(use.raw)
    y<-(-log10(top.matrix$P.Value))
  dot.cols[de.genes==1]=de.cols[1]
  dot.cols[de.genes==-1]=de.cols[2]
  dot.cols[de.genes==0]<-"black"
  de.genes<-unlist(de.genes,use.names = F)!=0
  pch=rep(16,nrow(top.matrix))
  bg=dot.cols
  not.de<-!de.genes
  if(!is.null(label.Ids))
  {
    idx=match(label.Ids,top.matrix$GeneID)
    pch[idx]=21
    dot.cols[idx]="yellow"
    not.de[idx]<-F
    de.genes[idx]<-T
  }
  plot(x[not.de],y[not.de],ylab = "-log10(p.value)",
       xlab = "log2 fold-change",cex=cex.points,
       cex.main=1,main = title,ylim=ylim,col=dot.cols[not.de],
       pch=pch[not.de],xlim=xlim,bg=bg[not.de])
  if(!is.null(label.Ids))
    de.genes[idx]=F
  lines(x[de.genes],y[de.genes],col=dot.cols[de.genes],type = "p",
        pch=pch[de.genes],cex=cex.points*key.size,bg=bg[de.genes])
  if(!is.null(label.Ids))
  {
    lines(x[idx],y[idx],col=dot.cols[idx],cex=cex.points*key.size,
          type = "p",pch=pch[idx],bg=bg[idx])
    fc2=x[idx]
    pval=y[idx]
    ar.x=rep((xlim[2]-2),length(label.Ids))
    ar.x[fc2<0]=xlim[1]+2
    ar.y=pval
    ar.y[fc2<0]=spaceLabels(ar.y[fc2<0],minDist = minDist)
    ar.y[fc2>0]=spaceLabels(ar.y[fc2>0],minDist = minDist)
    arrows(fc2,pval, x1 = ar.x, y1 =ar.y,length = 0,
           angle = angle,col = arrow.col)
    ar.x[ar.x<0]=ar.x[ar.x<0]-0.7
    ar.x[ar.x>0]=ar.x[ar.x>0]+0.7
    genes.2H=top.matrix$Symbol[idx]
    text(x =ar.x,y = ar.y,labels = genes.2H,cex=cex.lbl)
  }
}


#' Function that emulates the plotMD function in limma
#' @description
#' This function is a wrapper function to the plotMD \code{\link[limma:plotMD]{plotMD}} function in \code{\link[limma]{limma}} but adds
#' the ability to highlight selected genes or other features of interest
#' @param object an RGList, MAList, EList, ExpressionSet or MArrayLM object.
#' @param column integer, column of object to be plotted.
#' @param coef alternative to column for fitted model objects. If specified, then column is ignored.
#' @param xlab String, x-axis label
#' @param include.abline logical, include horizontal line
#' @param ylab String, y-axis label
#' @param xlim numeric vector, limits on the x-axis
#' @param ylim numeric vector, limits on the y-axis
#' @param de.cols vector list of colours used for highlght up-regulated and down-regulated genes
#' @param ... extra parameters are passed to the
#'
#' @export

plotMD.dc<-function(object, column = ncol(object), coef = NULL,cex.main=1,
                    xlab = "Average log-expression",include.abline=T,ylab = "logFC",cex.lbl=0.6,angle=30,
                    xlim=NULL,ylim=NULL,cex=0.3,de.cols=c("red","blue"),include.labels=T,label.only=NULL,
                    main = column,status,label.ids=NULL,max.distance=NULL,minDist=0.4,arrow.col="black",
                    label.offset=0.2,srt.lbl=20,...){
  not.de<-status==0
  dt.cols<-rep("black",length(status))
  dt.cols[status==1]=de.cols[1]
  dt.cols[status==-1]=de.cols[2]
  dot.cols<-dt.cols
  pch=rep(16,length(status))
  col.idx<-ifelse(is.null(coef),column,coef)
  if(!is.null(label.ids))
  {
    label.ids=unique(c(label.ids,label.only))
    not.de[names(status) %in% label.ids]<-F
    pch[names(status) %in% label.ids]<-21
    dot.cols[names(status) %in% label.ids]<-"yellow"
  }
  de<-!not.de
  logFC<-object$coefficients[,col.idx]
  avg<-object$Amean

  if(is.null(ylim))
  {
    val<-max(abs(logFC))+1
    ylim<-c(-val,val)
  }
  if(is.null(xlim))
  {
    xlim=c(min(avg)-1,max(avg)+1)
  }
  plot(avg[not.de],logFC[not.de],pch=pch[not.de],
       cex=cex,type="p",xlim = xlim,ylim = ylim,
       xlab = xlab,ylab = ylab,main = main,cex.main=cex.main,...)
  if(include.abline)
    abline(h=0, col="black")
  de.only<-de
  if(!is.null(label.ids)) de.only<-de & !(names(status) %in% label.ids)
  lines(avg[de.only],logFC[de.only],col=dot.cols[de.only],bg=dt.cols[de.only],
        pch=pch[de.only],type = "p",cex=cex*4)
  if(is.null(max.distance))
    max.distance=max(abs(logFC))
  if(!is.null(label.ids))
  {
    labels.only<-de & (names(status) %in% label.ids)
    lines(avg[labels.only],logFC[labels.only],col=dot.cols[labels.only],bg=dt.cols[labels.only],
          pch=pch[labels.only],type = "p",cex=cex*4)
    key.fit<-object[as.character(label.ids),col.idx]
    if(!is.null(label.only))
      key.fit<-object[as.character(label.only),col.idx]

    x<-key.fit$Amean
    y<-key.fit$coefficients
    if(include.labels)
    {
      ar.x=seq(from=xlim[1],to = xlim[2],length.out =length(x))
      names(ar.x)=names(sort(x,decreasing = F))
      ar.x=ar.x[names(x)]
      ar.x[y<0]=spaceLabels(ar.x[y<0],minDist = minDist)
      ar.x[y>0]=spaceLabels(ar.x[y>0],minDist = minDist)
      if(max(ar.x)>xlim[2]&min(ar.x)>xlim[1])
      {

      }
      ar.y=rep(ylim[1]+1,length(y))
      ar.y[y>0]=ylim[2]-1
      arrows(x0 = x,y0 = y, x1 = ar.x, y1 =ar.y,length = 0, angle = angle,col = arrow.col)
      ar.y[ar.y>0]=ar.y[ar.y>0]+label.offset
      ar.y[ar.y<0]=ar.y[ar.y<0]-label.offset
      text(x =ar.x,y = ar.y,labels = key.fit$genes$Symbol,cex=cex.lbl,srt=srt.lbl)
    }

  }
}


